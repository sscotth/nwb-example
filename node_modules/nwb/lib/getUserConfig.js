'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.prepareWebpackLoaderConfig = prepareWebpackLoaderConfig;
exports['default'] = getUserConfig;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _colours = require('./colours');

var _constants = require('./constants');

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _errors = require('./errors');

var _utils = require('./utils');

var DEFAULT_BUILD_CONFIG = {
  externals: {},
  global: '',
  jsNext: false,
  umd: false
};

var DEFAULT_WEBPACK_CONFIG = {
  loaders: {}
};

/**
 * Populate defaults for absent top level config, or fill in absent config which
 * is relied on downstream with default values.
 */
function applyDefaultConfig(userConfig, topLevelProp, defaults) {
  if (!(topLevelProp in userConfig)) {
    userConfig[topLevelProp] = _extends({}, defaults);
  } else {
    Object.keys(defaults).forEach(function (prop) {
      if (!(prop in userConfig[topLevelProp])) {
        userConfig[topLevelProp][prop] = defaults[prop];
      }
    });
  }
}

/**
 * Move loader query config tweaks into a query object, allowing users to
 * provide a flat config.
 */

function prepareWebpackLoaderConfig(loaders) {
  Object.keys(loaders).forEach(function (loaderId) {
    var loader = loaders[loaderId];
    if (loader.query) return loader;
    var config = loader.config;
    var exclude = loader.exclude;
    var include = loader.include;
    var test = loader.test;

    var query = _objectWithoutProperties(loader, ['config', 'exclude', 'include', 'test']);

    // eslint-disable-line no-unused-vars
    if (Object.keys(query).length > 0) {
      loader.query = query;
      Object.keys(query).forEach(function (prop) {
        return delete loader[prop];
      });
    }
  });
}

/**
 * Allow plugin configuration for the app's own CSS only to be provided as an
 * Array instad of an object with a defaults property.
 */
function prepareWebpackPostCSSConfig(postcss) {
  return Array.isArray(postcss) ? { defaults: postcss } : postcss;
}

function getUserConfig() {
  var args = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var _ref$required = _ref.required;
  var required = _ref$required === undefined ? false : _ref$required;

  // Try to load default user config, or use a config file path we were given
  var userConfig = {};
  var userConfigPath = _path2['default'].resolve(args.config || 'nwb.config.js');

  // Bail early if a config file is required and doesn't exist
  var configFileExists = _glob2['default'].sync(userConfigPath).length !== 0;
  if ((args.config || required) && !configFileExists) {
    throw new _errors.UserError('nwb: couldn\'t find a config file at ' + userConfigPath);
  }

  // If a config file exists, it should be a valid module regardless of whether
  // or not it's required.
  if (configFileExists) {
    try {
      userConfig = require(userConfigPath);
      _debug2['default']('imported config module from %s', userConfigPath);
    } catch (e) {
      throw new _errors.UserError('nwb: couldn\'t import the config file at ' + userConfigPath + ': ' + e);
    }
  }

  // Config modules can export a function if they need to access the current
  // command or the webpack dependency nwb manages for them.
  if (_utils.typeOf(userConfig) === 'function') {
    userConfig = userConfig({
      command: args._[0],
      webpack: _webpack2['default']
    });
  }

  function invalidConfig(type, value, message) {
    throw new _errors.UserError('nwb: invalid ' + type + ' config in ' + userConfigPath + ': ' + value, 'nwb: ' + type + ' ' + message);
  }

  if ((required || 'type' in userConfig) && _constants.PROJECT_TYPES.indexOf(userConfig.type) === -1) {
    invalidConfig('type', userConfig.type, 'must be one of: ' + _constants.PROJECT_TYPES.join(', '));
  }

  // Set defaults for config objects, as build config can contribute to webpack
  // config regardless of whether the user provided any.
  applyDefaultConfig(userConfig, 'build', DEFAULT_BUILD_CONFIG);
  applyDefaultConfig(userConfig, 'webpack', DEFAULT_WEBPACK_CONFIG);

  // TODO Remove in a future version
  if (userConfig.webpack.plugins) {
    console.log(_colours.magenta('nwb: webpack.plugins is deprecated as of nwb v0.11 - put this config directly under webpack in ' + userConfigPath + ' instead'));
    userConfig.webpack = _extends({}, userConfig.webpack, userConfig.webpack.plugins);
    delete userConfig.webpack.plugins;
  }

  // Expand webpack config where convenience shorthand is supported
  if (userConfig.webpack.loaders) {
    prepareWebpackLoaderConfig(userConfig.webpack.loaders);
  }
  if (userConfig.webpack.postcss) {
    userConfig.webpack.postcss = prepareWebpackPostCSSConfig(userConfig.webpack.postcss);
  }

  // If the user provided Babel config, automatically apply it to babel-loader
  // as query config unless there's already some set.
  if (userConfig.babel) {
    if (!userConfig.webpack.loaders.babel) {
      userConfig.webpack.loaders.babel = { query: userConfig.babel };
    } else if (!userConfig.webpack.loaders.babel.query) {
      userConfig.webpack.loaders.babel.query = userConfig.babel;
    }
  }

  _debug2['default']('user config: %s', _utils.deepToString(userConfig));

  return userConfig;
}
'use strict';

exports.__esModule = true;
exports.processPluginConfig = processPluginConfig;
exports.findPlugin = findPlugin;
exports.getKarmaConfig = getKarmaConfig;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _webpackMerge = require('webpack-merge');

var _webpackMerge2 = _interopRequireDefault(_webpackMerge);

var _createWebpackConfig = require('./createWebpackConfig');

var _createWebpackConfig2 = _interopRequireDefault(_createWebpackConfig);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _getPluginConfig = require('./getPluginConfig');

var _getPluginConfig2 = _interopRequireDefault(_getPluginConfig);

var _utils = require('./utils');

var DEFAULT_TESTS = 'tests/**/*-test.js';

/**
 * Framework and reporter config can be passed as strings or as plugin objects.
 * This handles figuring out which names and plugins have been provided and
 * automatically extracting a framework name from a plugin object.
 */

function processPluginConfig(configs) {
  var names = [];
  var plugins = [];
  configs.forEach(function (config) {
    if (_utils.typeOf(config) === 'string') {
      names.push(config);
    } else {
      names.push(Object.keys(config)[0].split(':').pop());
      plugins.push(config);
    }
  });
  return [names, plugins];
}

/**
 * Finds a karma plugin with the given type:name id. If a plugin object contains
 * multiple plugins (e.g. karma-chai-plugins), only the first will be checked.
 */

function findPlugin(plugins, findId) {
  for (var i = 0, l = plugins.length; i < l; i++) {
    if (_utils.typeOf(plugins[i]) !== 'object') {
      continue;
    }
    if (Object.keys(plugins[i])[0] === findId) {
      return plugins[i];
    }
  }
  return null;
}

/**
 * Handles creation of Karma config which can vary or be configured by the user.
 */

function getKarmaConfig() {
  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$codeCoverage = _ref.codeCoverage;
  var codeCoverage = _ref$codeCoverage === undefined ? false : _ref$codeCoverage;
  var userConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var _userConfig$karma = userConfig.karma;
  var userKarma = _userConfig$karma === undefined ? {} : _userConfig$karma;

  var frameworks = [];
  // Extra webpack loaders required for the generated Karma config.
  var extraLoaders = [];
  // Default reporter to be used if the user configures their own framework but
  // not their own reporter, as the mocha reporter doesn't play nicely with TAP
  // output and who knows which others.
  var reporters = ['dots'];
  // You don't seem to be able to mix specifying your own plugins with having
  // them magically located for you, so we're going to have to build a complete
  // list ourselves.
  var plugins = [require('karma-phantomjs-launcher'), require('karma-sourcemap-loader'), require('karma-webpack')];

  // Frameworks can be configured as a list containing names of bundled
  // frameworks, or framework plugin objects.
  if (userKarma.frameworks) {
    var _processPluginConfig = processPluginConfig(userKarma.frameworks);

    var frameworkNames = _processPluginConfig[0];
    var frameworkPlugins = _processPluginConfig[1];

    frameworks = frameworkNames;
    plugins = plugins.concat(frameworkPlugins);
  } else {
    // If the user didn't specify their own framework, use the Mocha framework
    // and reporter.
    frameworks = ['mocha'];
    reporters = ['mocha'];
  }

  // Reporters can be configured as a list containing names of bundled
  // reporters, or reporter plugin objects.
  if (userKarma.reporters) {
    var _processPluginConfig2 = processPluginConfig(userKarma.reporters);

    var reporterNames = _processPluginConfig2[0];
    var reporterPlugins = _processPluginConfig2[1];

    reporters = reporterNames;
    plugins = plugins.concat(reporterPlugins);
  }

  // Plugins can be provided as a list of imported plugin objects
  if (userKarma.plugins) {
    plugins = plugins.concat(userKarma.plugins);
  }

  // Ensure nwb's version of mocha plugins get loaded if they're going to be
  // used and haven't been provided by the user.
  if (frameworks.indexOf('mocha') !== -1 && !findPlugin(plugins, 'framework:mocha')) {
    plugins.push(require('karma-mocha'));
  }
  if (reporters.indexOf('mocha') !== -1 && !findPlugin(plugins, 'reporter:mocha')) {
    plugins.push(require('karma-mocha-reporter'));
  }

  if (codeCoverage) {
    extraLoaders.push({
      id: 'isparta',
      test: /\.jsx?$/,
      loader: require.resolve('isparta-loader'),
      include: _path2['default'].resolve('src')
    });
    reporters.push('coverage');
    plugins.push(require('karma-coverage'));
  }

  return { plugins: plugins, frameworks: frameworks, reporters: reporters, extraLoaders: extraLoaders };
}

exports['default'] = function (_ref2, userConfig) {
  var codeCoverage = _ref2.codeCoverage;
  var singleRun = _ref2.singleRun;

  var _preprocessors;

  var userKarma = userConfig.karma || {};
  var pluginConfig = _getPluginConfig2['default']();

  var _getKarmaConfig = getKarmaConfig({ codeCoverage: codeCoverage }, userConfig);

  var plugins = _getKarmaConfig.plugins;
  var frameworks = _getKarmaConfig.frameworks;
  var reporters = _getKarmaConfig.reporters;
  var extraLoaders = _getKarmaConfig.extraLoaders;

  var testFiles = _path2['default'].resolve(userKarma.tests || DEFAULT_TESTS);
  var preprocessors = (_preprocessors = {}, _preprocessors[require.resolve('babel-core/lib/polyfill')] = ['webpack'], _preprocessors[testFiles] = ['webpack', 'sourcemap'], _preprocessors);

  var webpackConfig = _createWebpackConfig2['default']({
    devtool: 'inline-source-map',
    loaders: {
      extra: extraLoaders
    },
    node: {
      fs: 'empty'
    },
    resolve: {
      alias: {
        'src': _path2['default'].resolve('src')
      },
      // Fall back to resolving runtime dependencies from nwb's dependencies
      fallback: _path2['default'].join(__dirname, '../node_modules')
    },
    server: true
  }, pluginConfig, userConfig.webpack);

  var karmaConfig = _webpackMerge2['default']({
    browsers: ['PhantomJS'],
    coverageReporter: {
      dir: _path2['default'].resolve('coverage'),
      reporters: [{ type: 'html', subdir: 'html' }, { type: 'lcovonly', subdir: '.' }]
    },
    files: [require.resolve('babel-core/lib/polyfill'), testFiles],
    frameworks: frameworks,
    mochaReporter: {
      showDiff: true
    },
    plugins: plugins,
    preprocessors: preprocessors,
    reporters: reporters,
    singleRun: singleRun,
    webpack: webpackConfig,
    webpackServer: {
      noInfo: true
    }
  }, userKarma.extra);

  _debug2['default']('karma config: %s', _utils.deepToString(karmaConfig));
  return karmaConfig;
};
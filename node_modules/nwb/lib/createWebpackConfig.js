'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.mergeLoaderConfig = mergeLoaderConfig;
exports.createStyleLoader = createStyleLoader;
exports.createLoaders = createLoaders;
exports.createExtraLoaders = createExtraLoaders;
exports.failBuildOnCompilationError = failBuildOnCompilationError;
exports.createPlugins = createPlugins;
exports.getTopLevelLoaderConfig = getTopLevelLoaderConfig;
exports.createPostCSSConfig = createPostCSSConfig;
exports.getCompatConfig = getCompatConfig;
exports['default'] = createWebpackConfig;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _autoprefixer = require('autoprefixer');

var _autoprefixer2 = _interopRequireDefault(_autoprefixer);

var _extractTextWebpackPlugin = require('extract-text-webpack-plugin');

var _extractTextWebpackPlugin2 = _interopRequireDefault(_extractTextWebpackPlugin);

var _htmlWebpackPlugin = require('html-webpack-plugin');

var _htmlWebpackPlugin2 = _interopRequireDefault(_htmlWebpackPlugin);

var _npmInstallWebpackPlugin = require('npm-install-webpack-plugin');

var _npmInstallWebpackPlugin2 = _interopRequireDefault(_npmInstallWebpackPlugin);

var _qs = require('qs');

var _qs2 = _interopRequireDefault(_qs);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

var _webpackMerge = require('webpack-merge');

var _webpackMerge2 = _interopRequireDefault(_webpackMerge);

var _colours = require('./colours');

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _utils = require('./utils');

// Default query configuration for file-loader and url-loader
var FILE_LOADER_DEFAULTS = {
  name: '[name].[hash:8].[ext]'
};

// Top-level property names reserved for webpack config
// From http://webpack.github.io/docs/configuration.html
var WEBPACK_RESERVED = 'context entry output module resolve resolveLoader externals target bail profile cache watch watchOptions debug devtool devServer node amd loader recordsPath recordsInputPath recordsOutputPath plugins'.split(' ');

/**
 * Create a loader string from a list of {loader, query} objects.
 */
var combineLoaders = function combineLoaders(loaders) {
  return loaders.map(function (loader) {
    var query = _qs2['default'].stringify(loader.query, { arrayFormat: 'brackets' });
    return '' + loader.loader + (query && '?' + query);
  }).join('!');
};

exports.combineLoaders = combineLoaders;
/**
 * Merge webpack loader config ({test, loader, query, inclue, exclude}) objects.
 */

function mergeLoaderConfig() {
  var defaultConfig = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  // Don't include a 'config' object if the user provided one - this will be
  // configured at the top level instead.
  var config = userConfig.config;

  var userLoaderConfig = _objectWithoutProperties(userConfig, ['config']);

  // eslint-disable-line no-unused-vars
  var loader = _webpackMerge2['default'](defaultConfig, buildConfig, userLoaderConfig);
  if (loader.query && Object.keys(loader.query).length === 0) {
    delete loader.query;
  }
  return loader;
}

/**
 * Create a function which configures a loader identified by a unique id, with
 * the option to override defaults with build-specific and user config.
 */
var loaderConfigFactory = function loaderConfigFactory(buildConfig, userConfig) {
  return function (id, defaultConfig) {
    if (id) {
      return _extends({ id: id }, mergeLoaderConfig(defaultConfig, buildConfig[id], userConfig[id]));
    }
    return defaultConfig;
  };
};

exports.loaderConfigFactory = loaderConfigFactory;
/**
 * Create a function which applies a prefix to a given name when a prefix is
 * given, unless the prefix ends with a name, in which case the prefix itself is
 * returned.
 * The latter rule is to allow loaders created for CSS preprocessor plugins to
 * be given unique ids for user configuration without duplicating the name of
 * the loader.
 * e.g.: styleLoaderName('sass')('css') => 'sass-css'
 *       styleLoaderName('sass')('sass') => 'sass' (as opposed to 'sass-sass')
 */
var styleLoaderName = function styleLoaderName(prefix) {
  return function (name) {
    if (prefix && _utils.endsWith(prefix, name)) {
      return prefix;
    }
    return prefix ? prefix + '-' + name : name;
  };
};

exports.styleLoaderName = styleLoaderName;
/**
 * Create a default style-handling pipeline for either a static build (default)
 * or a server build.
 */

function createStyleLoader(loader, server) {
  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref$prefix = _ref.prefix;
  var prefix = _ref$prefix === undefined ? null : _ref$prefix;
  var _ref$extraLoader = _ref.extraLoader;
  var extraLoader = _ref$extraLoader === undefined ? null : _ref$extraLoader;

  var name = styleLoaderName(prefix);
  var loaders = [loader(name('css'), {
    loader: require.resolve('css-loader'),
    query: {
      // Apply postcss-loader to @imports
      importLoaders: 1
    }
  }), loader(name('postcss'), {
    loader: require.resolve('postcss-loader'),
    query: {
      pack: prefix
    }
  })];

  if (extraLoader) {
    loaders.push(loader(name(extraLoader.id), extraLoader.config));
  }

  if (server) {
    loaders.unshift(loader(name('style'), {
      loader: require.resolve('style-loader')
    }));
    return combineLoaders(loaders);
  } else {
    return _extractTextWebpackPlugin2['default'].extract(require.resolve('style-loader'), combineLoaders(loaders));
  }
}

/**
 * Final webpack loader config consists of:
 * - the default set of loaders created in this function, with build and user
 *   config tweaks based on loader id.
 * - extra loaders defined in build config, with user config tweaks based
 *   on loader id.
 * - extra loaders created for CSS preprocessor plugins, with user config
 *   tweaks based on loader id.
 * - extra loaders defined in user config.
 */

function createLoaders(server) {
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  var pluginConfig = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var loader = loaderConfigFactory(buildConfig, userConfig);

  var loaders = [loader('babel', {
    test: /\.jsx?$/,
    loader: require.resolve('babel-loader'),
    exclude: /node_modules/,
    query: {
      // Ignore any .babelrc files in the app or its path
      breakConfig: true,
      // Cache transformations to the filesystem (in default OS temp dir)
      cacheDirectory: true
    }
  }), loader('css-pipeline', {
    test: /\.css$/,
    loader: createStyleLoader(loader, server),
    exclude: /node_modules/
  }), loader('vendor-css-pipeline', {
    test: /\.css$/,
    loader: createStyleLoader(loader, server, {
      prefix: 'vendor'
    }),
    include: /node_modules/
  }), loader('graphics', {
    test: /\.(gif|png)$/,
    loader: require.resolve('url-loader'),
    query: _extends({
      limit: 10240
    }, FILE_LOADER_DEFAULTS)
  }), loader('jpeg', {
    test: /\.jpe?g$/,
    loader: require.resolve('file-loader'),
    query: _extends({}, FILE_LOADER_DEFAULTS)
  }), loader('fonts', {
    test: /\.(otf|svg|ttf|woff|woff2)(\?v=\d+\.\d+\.\d+)?$/,
    loader: require.resolve('url-loader'),
    query: _extends({
      limit: 10240
    }, FILE_LOADER_DEFAULTS)
  }), loader('eot', {
    test: /\.eot(\?v=\d+\.\d+\.\d+)?$/,
    loader: require.resolve('file-loader'),
    query: _extends({}, FILE_LOADER_DEFAULTS)
  }), loader('json', {
    test: /\.json$/,
    loader: require.resolve('json-loader')
  })].concat(createExtraLoaders(buildConfig.extra, userConfig));

  if (pluginConfig.cssPreprocessors) {
    Object.keys(pluginConfig.cssPreprocessors).forEach(function (id) {
      var _pluginConfig$cssPreprocessors$id = pluginConfig.cssPreprocessors[id];
      var test = _pluginConfig$cssPreprocessors$id.test;

      var config = _objectWithoutProperties(_pluginConfig$cssPreprocessors$id, ['test']);

      loaders.push(loader(id + '-pipeline', {
        test: test,
        loader: createStyleLoader(loader, server, {
          extraLoader: { id: id, config: config },
          prefix: id
        }),
        exclude: /node_modules/
      }));
      loaders.push(loader('vendor-' + id + '-pipeline', {
        test: test,
        loader: createStyleLoader(loader, server, {
          extraLoader: { id: id, config: config },
          prefix: 'vendor-' + id
        }),
        include: /node_modules/
      }));
    });
  }

  return loaders;
}

/**
 * Create loaders from loader definitions which may include an id attribute for
 * user customisation. It's assumed these are being created from build config.
 */

function createExtraLoaders() {
  var extraLoaders = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var userConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var loader = loaderConfigFactory({}, userConfig);
  return extraLoaders.map(function (extraLoader) {
    var id = extraLoader.id;

    var loaderConfig = _objectWithoutProperties(extraLoader, ['id']);

    return loader(id, loaderConfig);
  });
}

/**
 * A webpack plugin which forces the build to fail by exiting with a non-zero
 * code when there are compilation errors. This is intended for use on a CI
 * server which is running webpack builds.
 */

function failBuildOnCompilationError() {
  this.plugin('done', function (_ref2) {
    var compilation = _ref2.compilation;

    if (compilation.errors && compilation.errors.length > 0) {
      console.error(_colours.red('nwb: webpack build failed:'));
      compilation.errors.forEach(function (error) {
        return console.error(_colours.red(error.message));
      });
      process.exit(1);
    }
  });
}

/**
 * Final webpack plugin config consists of:
 * - the default set of plugins created by this function based on whether or not
 *   a server build is being configured, plus environment variables.
 * - extra plugins managed by this function, whose inclusion is triggered by
 *   build config, which provides default configuration for them which can be
 *   tweaked by user plugin config when appropriate.
 * - any extra plugins defined in build and user config.
 */

function createPlugins(server) {
  var buildConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var plugins = [new _webpack2['default'].DefinePlugin(_extends({
    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development')
  }, buildConfig.define, userConfig.define)), new _webpack.optimize.OccurenceOrderPlugin()];

  // Assumption: we're always hot reloading if we're bundling on the server
  if (server) {
    plugins.unshift(new _webpack2['default'].HotModuleReplacementPlugin(), new _webpack2['default'].NoErrorsPlugin());
  }

  if (process.env.CONTINUOUS_INTEGRATION === 'true') {
    plugins.unshift(failBuildOnCompilationError);
  }

  if (!server) {
    plugins.push(new _extractTextWebpackPlugin2['default']('[name].css', _extends({}, userConfig.extractText)));

    // Move modules imported from node_modules into a vendor chunk
    if (userConfig.vendorBundle !== false && buildConfig.vendorChunkName) {
      plugins.push(new _webpack.optimize.CommonsChunkPlugin({
        name: buildConfig.vendorChunkName,
        minChunks: function minChunks(module, count) {
          return module.resource && module.resource.indexOf(_path2['default'].resolve('node_modules')) === 0;
        }
      }));
    }
  }

  if (process.env.NODE_ENV === 'production') {
    plugins.push(new _webpack.optimize.DedupePlugin());
    plugins.push(new _webpack.optimize.UglifyJsPlugin({
      compress: {
        screw_ie8: true,
        warnings: false
      }
    }));
  }

  if (buildConfig.html) {
    plugins.push(new _htmlWebpackPlugin2['default'](_extends({
      template: _path2['default'].join(__dirname, '../templates/webpack-template.html')
    }, buildConfig.html, userConfig.html)));
  }

  if (buildConfig.install) {
    plugins.push(new _npmInstallWebpackPlugin2['default'](_extends({}, buildConfig.install, userConfig.install)));
  }

  if (buildConfig.banner) {
    plugins.push(new _webpack2['default'].BannerPlugin(buildConfig.banner));
  }

  if (buildConfig.extra) {
    plugins = plugins.concat(buildConfig.extra);
  }

  return plugins;
}

/**
 * Extract top-level loader configuration provided by the user.
 */

function getTopLevelLoaderConfig(userLoaderConfig) {
  var cssPreprocessors = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  if (!userLoaderConfig || Object.keys(userLoaderConfig).length === 0) {
    return {};
  }

  var topLevelLoaderConfig = {};
  Object.keys(userLoaderConfig).forEach(function (loaderId) {
    var loaderConfig = userLoaderConfig[loaderId];
    if (!('config' in loaderConfig)) return;

    // Determine the proeprty to set top level loader config under
    var configPropertyName = undefined;

    // Trust the user to specify their own config key for loaders with support
    if (loaderConfig.query && 'config' in loaderConfig.query) {
      configPropertyName = loaderConfig.query.config;
    } else {
      // Otherwise, determine the correct config key
      var id = loaderId.replace(/^vendor-/, '');
      if (id in cssPreprocessors) {
        if (!cssPreprocessors[id].defaultConfig) {
          throw new Error('The ' + id + ' CSS preprocessor loader doesn\'t support a default top-level config object.');
        }
        configPropertyName = cssPreprocessors[id].defaultConfig;
      } else if (id === 'babel') {
        configPropertyName = 'babel';
      } else {
        throw new Error('The ' + id + ' loader doesn\'t appear to support a default top-level config object.');
      }
    }

    if (WEBPACK_RESERVED.indexOf(configPropertyName) !== -1) {
      throw new Error('User config for the ' + loaderId + ' loader cannot be set in ' + configPropertyName + ' - this is reserved for use by Webpack.');
    } else if (configPropertyName in topLevelLoaderConfig) {
      throw new Error('User config for the ' + loaderId + ' loader cannot be set in ' + configPropertyName + ' - this has already been used.');
    }

    topLevelLoaderConfig[configPropertyName] = loaderConfig.config;
  });

  return topLevelLoaderConfig;
}

/**
 * Create top-level PostCSS plugin config for each style pipeline.
 */

function createPostCSSConfig(userPostCSSConfig) {
  var cssPreprocessors = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  // postcss-loader throws an error if a pack name is provided but isn't
  // configured, so we need to set the default PostCSS plugins for every single
  // style pipeline.
  var postcss = {
    defaults: [_autoprefixer2['default']()],
    vendor: [_autoprefixer2['default']()]
  };
  Object.keys(cssPreprocessors).forEach(function (id) {
    postcss[id] = [_autoprefixer2['default']()];
  });
  // PostCSS plugins provided by the user will completely overwrite defaults
  return _extends({}, postcss, userPostCSSConfig);
}

var COMPAT_CONFIGS = {
  enzyme: {
    externals: {
      'react/addons': true,
      'react/lib/ExecutionEnvironment': true,
      'react/lib/ReactContext': true
    }
  },
  moment: function moment(_ref3) {
    var locales = _ref3.locales;

    if (!Array.isArray(locales)) {
      console.error(_colours.red("nwb: webpack.compat.moment config must provide a 'locales' Array"));
      return;
    }
    return {
      plugins: [new _webpack2['default'].ContextReplacementPlugin(/moment[\\\/]locale$/, new RegExp('^\\.\\/(' + locales.join('|') + ')$'))]
    };
  },
  sinon: {
    module: {
      noParse: /[/\\]sinon\.js/
    },
    resolve: {
      alias: {
        sinon: 'sinon/pkg/sinon'
      }
    }
  }
};

exports.COMPAT_CONFIGS = COMPAT_CONFIGS;
/**
 * Create a chunk of webpack config containing compatibility tweaks for
 * libraries which are known to cause issues, to be merged into the generated
 * config.
 * Returns null if there's nothing to merge based on user config.
 */

function getCompatConfig() {
  var userCompatConfig = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var configs = [];
  Object.keys(userCompatConfig).map(function (lib) {
    if (!userCompatConfig[lib]) return;
    if (!COMPAT_CONFIGS.hasOwnProperty(lib)) {
      console.error(_colours.red('nwb: unknown property in webpack.compat config: ' + lib));
      return;
    }
    var compatConfig = COMPAT_CONFIGS[lib];
    if (typeof compatConfig == 'function') {
      compatConfig = compatConfig(userCompatConfig[lib]);
      if (!compatConfig) return;
    }
    configs.push(compatConfig);
  });
  return configs.length > 0 ? _webpackMerge2['default'].apply(undefined, configs) : null;
}

/**
 * Create a webpack config with a curated set of default loaders suitable for
 * creating a static build (default) or serving an app with hot reloading.
 */

function createWebpackConfig(buildConfig) {
  var nwbPluginConfig = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var userConfig = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  _debug2['default']('createWebpackConfig buildConfig: %s', _utils.deepToString(buildConfig));

  // Final webpack config is primarily driven by build configuration for the nwb
  // command being run. Each command configures a default, working webpack
  // configuration for the task it needs to perform.
  var _buildConfig$loaders = buildConfig.loaders;
  var
  // These build config items are used to create chunks of webpack config,
  // rather than being included as-is.
  loaders = _buildConfig$loaders === undefined ? {} : _buildConfig$loaders;
  var _buildConfig$plugins = buildConfig.plugins;
  var plugins = _buildConfig$plugins === undefined ? {} : _buildConfig$plugins;
  var _buildConfig$resolve = buildConfig.resolve;
  var resolve = _buildConfig$resolve === undefined ? {} : _buildConfig$resolve;
  var _buildConfig$server = buildConfig.server;
  var server = _buildConfig$server === undefined ? false : _buildConfig$server;

  var otherBuildConfig = _objectWithoutProperties(buildConfig, ['loaders', 'plugins', 'resolve', 'server']);

  var webpackConfig = _extends({
    module: {
      loaders: createLoaders(server, loaders, userConfig.loaders, nwbPluginConfig)
    },
    plugins: createPlugins(server, plugins, userConfig),
    resolve: _webpackMerge2['default']({
      extensions: ['', '.web.js', '.js', '.jsx', '.json'],
      // Fall back to resolving runtime dependencies from nwb's dependencies,
      // e.g. for babel-runtime when using Babel stage: 0 and optional:
      // ['runtime'] for async/await.
      fallback: _path2['default'].join(__dirname, '../node_modules')
    }, resolve),
    postcss: createPostCSSConfig(userConfig.postcss, nwbPluginConfig.cssPreprocessors)
  }, otherBuildConfig, getTopLevelLoaderConfig(userConfig.loaders, nwbPluginConfig.cssPreprocessors));

  // Create and merge compatibility configuration into the generated config if
  // specified.
  if (userConfig.compat) {
    var compatConfig = getCompatConfig(userConfig.compat);
    if (compatConfig) {
      webpackConfig = _webpackMerge2['default'](webpackConfig, compatConfig);
    }
  }

  // Any extra user webpack config is merged into the generated config to give
  // them even more control.
  if (userConfig.extra) {
    webpackConfig = _webpackMerge2['default'](webpackConfig, userConfig.extra);
  }

  return webpackConfig;
}

// Extra loaders from build config, still configurable via user config when
// the loaders specify an id.

// Any other build config provided is merged directly into the final webpack
// config to provide the rest of the default config.

// Top level loader config can be supplied via user "loaders" config, so we
// detect, extract and where possible validate it before merging it into the
// final webpack config object.